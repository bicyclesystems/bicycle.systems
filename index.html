<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bicycle. Just think</title>
    <link rel="icon" href="./images/favicon.png" type="image/png">
    <script defer data-domain="bicycle.systems" src="https://plausible.io/js/script.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Times New Roman', Times, serif;
            line-height: 1.6; 
            color: #333; 
        }
        
        h1, h2, h3, h4, h5, h6 { font-weight: 500; line-height: 1.2; margin-bottom: 0.5em; }
        h5 { font-size: 1.8rem; margin-bottom: 1rem; }
        
        .view { min-height: 100vh; width: 100%; padding: 1rem; }
        .container { max-width: 800px; width: 100%; padding: 2rem; margin: 0 auto; }
        #conversation-flow { padding-bottom: 25vh; position: relative; }
        
        .bicycle-image { 
            width: 100vw; 
            margin-bottom: 2rem; 
            opacity: 1;
            transition: opacity 2s;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .bicycle-image.fade-out { opacity: 0; pointer-events: none; }
        
        .background-image-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            pointer-events: none;
            background-color: rgba(255, 255, 255, 0.97);
        }
        
        .background-image {
            position: absolute;
            display: block;
            pointer-events: none;
            mix-blend-mode: multiply;
            filter: contrast(1.05) brightness(1.1) saturate(0.9);
            max-height: 40vh;
            max-width: 40vw;
            object-fit: contain;
            opacity: 0;
            transition: opacity 2s;
        }
        
        .background-image.active { opacity: 1; pointer-events: auto; }
        
        /* Position classes */
        .top-left { top: 40px; left: 40px; }
        .top-right { top: 40px; right: 40px; }
        .bottom-left { bottom: 40px; left: 40px; }
        .bottom-right { bottom: 40px; right: 40px; }
        .center {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .center-left {
            top: 50%;
            left: 40px;
            transform: translateY(-50%);
        }
        .center-right {
            top: 50%;
            right: 40px;
            transform: translateY(-50%);
        }
        .top {
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
        }
        .bottom {
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .section {
            opacity: 0;
            height: 0;
            overflow: hidden;
            pointer-events: none;
            position: absolute;
            left: 0; right: 0;
        }
        
        .section.active {
            opacity: 1;
            height: auto;
            overflow: visible;
            pointer-events: auto;
            position: relative;
        }
        
        .nav-buttons {
            display: none;
            opacity: 0;
            margin-top: 2rem;
        }
        
        .nav-buttons.visible {
            display: flex;
            flex-direction: column;
            opacity: 1;
        }
        
        .topic-paragraph {
            opacity: 0.5;
            transition: opacity 0.3s;
            cursor: pointer;
            margin-bottom: 0.75rem;
        }
        
        .topic-paragraph:hover { opacity: 1; }
        .paragraph { margin-bottom: 1rem; }
        .question { font-weight: 500; margin-bottom: 1.5rem; }
        .typewriter-content { margin-bottom: 1rem; }
        
        @media (max-width: 768px) {
            .container { padding: 1rem; }
            .background-image { 
                max-height: 50vh;
                max-width: 60vw;
            }
        }
        .fade-in-char {
            opacity: 0;
            transition: opacity 0.4s;
            /* display: inline-block; */
        }
        .fade-in-char.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="background-image-container" id="background-container"></div>
    <div class="view">
        <img src="./images/bicycle.png" alt="Bicycle" class="bicycle-image">
        <div class="container" style="mix-blend-mode:difference; color:white;">
            <div id="conversation-flow"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            window.scrollTo(0, 0);
            new BicycleApp();
        });

        // --- Utility Functions ---
        function wait(ms) { return new Promise(res => setTimeout(res, ms)); }
        function isUserAtBottom() {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const windowHeight = window.innerHeight;
            const documentHeight = Math.max(
                document.body.scrollHeight, document.body.offsetHeight,
                document.documentElement.clientHeight, document.documentElement.scrollHeight,
                document.documentElement.offsetHeight
            );
            return documentHeight - (scrollTop + windowHeight) <= 100;
        }
        function scrollToBottom() {
            if (isUserAtBottom()) {
                window.scrollTo({top: document.body.scrollHeight, behavior: 'auto'});
            }
        }
        function createEl(tag, className, text) {
            const el = document.createElement(tag);
            if (className) el.className = className;
            if (text) el.textContent = text;
            return el;
        }

        class BicycleApp {
            constructor() {
                this.conversationFlow = document.getElementById('conversation-flow');
                this.bgContainer = document.getElementById('background-container');
                this.sections = {};
                this.introText = "";
                this.isTyping = false;
                this.answered = new Set();
                this.imageCache = {};
                this.positions = [
                    'bottom-left', 'bottom-right', 'center', 'center-left', 'center-right', 'top', 'top-right', 'top-left'
                ];
                this.currentPosition = 0;
                this.currentTextPosition = null;
                this.previousImagePosition = null;
                this.navButtons = createEl('div', 'nav-buttons');
                this.navButtons.id = 'nav-buttons';
                window.addEventListener('hashchange', () => this.handleHashChange());
                window.addEventListener('resize', () => {});
                this.init();
            }
            async init() {
                await this.loadContent();
                const hash = window.location.hash.substring(1);
                if (hash && this.sections[this.getTitleFromHash(hash)]) {
                    const bicycleImage = document.querySelector('.bicycle-image');
                    if (bicycleImage) {
                        bicycleImage.classList.add('fade-out');
                        await wait(2000);
                        bicycleImage.style.display = 'none';
                    }
                    await this.showSection(this.getSectionId(this.getTitleFromHash(hash)), this.getTitleFromHash(hash));
                    return;
                }
                this.startIntro();
            }
            async loadContent() {
                const response = await fetch('BICYCLE_FOR_THE_MIND.MD');
                if (!response.ok) throw new Error(`Failed to fetch markdown: ${response.status}`);
                const text = await response.text();
                const { intro, sections } = this.parseMarkdown(text);
                this.introText = intro;
                this.sections = sections;
                this.createNavButtons();
            }
            parseMarkdown(text) {
                const lines = text.split('\n');
                let current = null, content = [], sections = {}, intro = "";
                for (const line of lines) {
                    if (line.startsWith('## ')) {
                        if (current) sections[current] = content.join('\n');
                        else if (content.length) intro = content.join('\n');
                        current = line.substring(3).trim();
                        content = [];
                    } else content.push(line);
                }
                if (current) sections[current] = content.join('\n');
                else if (content.length && !intro) intro = content.join('\n');
                if (!intro && Object.keys(sections).length) {
                    const first = Object.keys(sections)[0];
                    intro = sections[first];
                    delete sections[first];
                }
                return { intro, sections };
            }
            createNavButtons() {
                this.navButtons.innerHTML = '';
                Object.keys(this.sections).forEach(title => {
                    const btn = createEl('h5', 'topic-paragraph', title);
                    btn.dataset.section = this.getSectionId(title);
                    btn.onclick = () => {
                        if (this.isTyping) return;
                        this.navButtons.classList.remove('visible');
                        this.showSection(btn.dataset.section, title);
                    };
                    this.navButtons.appendChild(btn);
                });
            }
            getSectionId(title) {
                return title.toUpperCase().replace(/[^A-Z0-9]+/g, '-').replace(/^-+|-+$/g, '');
            }
            getTitleFromHash(hash) {
                return Object.keys(this.sections).find(title => this.getSectionId(title) === hash);
            }
            async startIntro() {
                window.scrollTo(0, 0);
                const bicycleImage = document.querySelector('.bicycle-image');
                await wait(2000);
                bicycleImage.classList.add('fade-out');
                const section = createEl('section', 'section active');
                section.id = 'INTRODUCTION-section';
                this.conversationFlow.appendChild(section);
                const content = createEl('div', 'typewriter-content');
                content.id = 'typewriter-content';
                section.appendChild(content);
                this.isTyping = true;
                await this.typeText(content, this.introText, true);
                this.isTyping = false;
                bicycleImage.style.display = 'none';
                if (this.navButtons.parentNode) this.navButtons.parentNode.removeChild(this.navButtons);
                section.after(this.navButtons);
                this.navButtons.classList.add('visible');
                document.querySelectorAll('.background-image.active').forEach(img => img.classList.remove('active'));
                this.bgContainer.style.backgroundColor = 'rgba(255, 255, 255, 1)';
            }
            async showSection(sectionId, sectionTitle) {
                const existing = document.getElementById(`${sectionId}-section`);
                if (existing) {
                    document.querySelectorAll('.section.active').forEach(s => s.classList.remove('active'));
                    existing.classList.add('active');
                    this.moveNavButtons(existing);
                    return;
                }
                if (this.answered.has(sectionId)) return;
                this.answered.add(sectionId);
                this.isTyping = true;
                const newHash = `#${sectionId}`;
                if (window.location.hash !== newHash) window.history.replaceState(null, '', newHash);
                document.querySelectorAll('.section.active').forEach(s => s.classList.remove('active'));
                const section = createEl('section', 'section active');
                section.id = `${sectionId}-section`;
                this.conversationFlow.appendChild(section);
                section.appendChild(createEl('h5', 'question', sectionTitle));
                const contentWrapper = createEl('div');
                section.appendChild(contentWrapper);
                const content = createEl('div', 'typewriter-content');
                content.id = `${sectionId}-content`;
                contentWrapper.appendChild(content);
                await this.typeText(content, this.sections[sectionTitle], false);
                this.isTyping = false;
                this.moveNavButtons(section);
            }
            async typeText(element, text, enableImageMatch = false) {
                element.innerHTML = '';
                let currentParagraph = createEl('h5', 'paragraph');
                element.appendChild(currentParagraph);
                const parseSegments = md => {
                    const regex = /\[([^\]]+)\]\(([^)]+)\)/g;
                    let last = 0, match, segs = [];
                    while ((match = regex.exec(md))) {
                        if (match.index > last) segs.push({ type: 'text', content: md.slice(last, match.index) });
                        segs.push({ type: 'link', content: match[1], href: match[2] });
                        last = regex.lastIndex;
                    }
                    if (last < md.length) segs.push({ type: 'text', content: md.slice(last) });
                    return segs;
                };
                const segments = enableImageMatch ? parseSegments(text) : [{ type: 'text', content: text }];
                let shouldPause = false, currentWord = '';
                for (const segment of segments) {
                    let segContent = segment.content, segHref = segment.href, isLink = segment.type === 'link', node;
                    if (isLink) {
                        node = document.createElement('a');
                        node.href = segHref;
                        node.target = '_blank';
                        node.rel = 'noopener noreferrer';
                        node.style.textDecoration = 'underline';
                        node.style.color = 'inherit';
                        let linkSpan = createEl('span', 'fade-in-char', segContent);
                        node.appendChild(linkSpan);
                        currentParagraph.appendChild(node);
                        void linkSpan.offsetWidth;
                        linkSpan.classList.add('visible');
                        await wait(30 * segContent.length);
                        continue;
                    } else {
                        node = document.createTextNode('');
                        currentParagraph.appendChild(node);
                    }
                    for (let i = 0; i < segContent.length; i++) {
                        const char = segContent[i];
                        this.updateCurrentTextPosition(currentParagraph);
                        if (char === '\n') {
                            if (currentParagraph.childNodes.length && currentParagraph.textContent.trim() !== '') {
                                currentParagraph = createEl('h5', 'paragraph');
                                element.appendChild(currentParagraph);
                                node = document.createTextNode('');
                                currentParagraph.appendChild(node);
                            }
                            scrollToBottom();
                            await wait(300);
                            shouldPause = false;
                        } else {
                            let charNode;
                            if (char !== ' ' && char !== '\u00A0') {
                                charNode = createEl('span', 'fade-in-char', char);
                                currentParagraph.appendChild(charNode);
                                void charNode.offsetWidth;
                                charNode.classList.add('visible');
                            } else {
                                currentParagraph.appendChild(document.createTextNode(char));
                            }
                            if (enableImageMatch) {
                                if (/\s/.test(char) || /[.,!?;:]/.test(char)) {
                                    if (currentWord.trim().length > 3) this.tryLoadImage(currentWord.trim());
                                    currentWord = '';
                                } else currentWord += char;
                            }
                            let delay = 30;
                            if (['.', '!', '?'].includes(char)) { delay = 300; shouldPause = true; }
                            else if ([',', ';', ':'].includes(char)) delay = 150;
                            else if (shouldPause) { delay = 100; shouldPause = false; }
                            scrollToBottom();
                            await wait(delay);
                        }
                    }
                    if (enableImageMatch && currentWord.trim().length > 3) {
                        this.tryLoadImage(currentWord.trim());
                        currentWord = '';
                    }
                }
            }
            updateCurrentTextPosition(element) {
                if (!element) return;
                const rect = element.getBoundingClientRect();
                const vh = window.innerHeight, vw = window.innerWidth;
                this.currentTextPosition = {
                    isTop: rect.top < (vh / 2),
                    isLeft: rect.left < (vw / 2),
                    element
                };
            }
            tryLoadImage(word) {
                if (!word || word.length <= 3) return;
                word = word.toLowerCase().replace(/[^\w\s]/g, '');
                const key = word;
                if (this.imageCache[key]) return this.showImage(this.imageCache[key]);
                const img = new Image();
                img.className = `background-image ${this.getPositionFarFromText()}`;
                img.onload = () => {
                    this.bgContainer.appendChild(img);
                    const imageInfo = { word: key, element: img };
                    this.imageCache[key] = imageInfo;
                    this.showImage(imageInfo);
                };
                img.onerror = () => {};
                img.src = `intro/${key}.png`;
            }
            showImage(imageInfo) {
                document.querySelectorAll('.background-image.active').forEach(img => img.classList.remove('active'));
                const oldPos = imageInfo.element.className.split(' ')[1];
                const newPos = this.getPositionFarFromText();
                imageInfo.element.classList.remove(oldPos);
                imageInfo.element.classList.add(newPos);
                if (!this.bgContainer.contains(imageInfo.element)) this.bgContainer.appendChild(imageInfo.element);
                imageInfo.element.classList.add('active');
            }
            getPositionFarFromText() {
                if (!this.currentTextPosition) {
                    let pos = this.positions[this.currentPosition];
                    if (this.previousImagePosition && this.positions.length > 1) {
                        let attempts = 0;
                        while (pos === this.previousImagePosition && attempts < this.positions.length) {
                            this.currentPosition = (this.currentPosition + 1) % this.positions.length;
                            pos = this.positions[this.currentPosition];
                            attempts++;
                        }
                    }
                    this.previousImagePosition = pos;
                    this.currentPosition = (this.currentPosition + 1) % this.positions.length;
                    return pos;
                }
                let opp = [];
                if (this.currentTextPosition.isTop && this.currentTextPosition.isLeft) opp = ['bottom-right', 'bottom', 'center', 'center-right'];
                else if (this.currentTextPosition.isTop && !this.currentTextPosition.isLeft) opp = ['bottom-left', 'bottom', 'center', 'center-left'];
                else if (!this.currentTextPosition.isTop && this.currentTextPosition.isLeft) opp = ['top-right', 'top', 'center', 'center-right'];
                else opp = ['top-left', 'top', 'center', 'center-left'];
                if (this.previousImagePosition && opp.length > 1) opp = opp.filter(pos => pos !== this.previousImagePosition);
                const newPos = opp[Math.floor(Math.random() * opp.length)];
                this.previousImagePosition = newPos;
                return newPos;
            }
            moveNavButtons(section) {
                if (this.navButtons.parentNode) this.navButtons.parentNode.removeChild(this.navButtons);
                section.after(this.navButtons);
                this.navButtons.classList.add('visible');
                if (isUserAtBottom()) window.scrollTo({top: document.body.scrollHeight, behavior: 'smooth'});
            }
            handleHashChange() {
                const hash = window.location.hash.substring(1);
                if (!hash) return;
                const sectionTitle = this.getTitleFromHash(hash);
                if (!sectionTitle || !this.sections[sectionTitle]) return;
                const sectionId = this.getSectionId(sectionTitle);
                const existing = document.getElementById(`${sectionId}-section`);
                document.querySelectorAll('.section.active').forEach(s => s.classList.remove('active'));
                if (existing) {
                    existing.classList.add('active');
                    this.moveNavButtons(existing);
                } else {
                    this.showSection(sectionId, sectionTitle);
                }
            }
        }
    </script>
</body>
</html>