<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The birth of a new era (and The End of Traditional Computing as we know it).</title>
    <link rel="icon" href="./images/favicon.png" type="image/png">
    <link rel="stylesheet" href="https://unpkg.com/@rnbws/renecss/dist/rene.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/2.0.3/marked.min.js"></script>
    <style>
        .section{display:none}.section.active{display:block;animation:fadeIn .5s}
        .nav-buttons{display:none}.nav-buttons.visible{display:flex;flex-direction:column;animation:fadeIn .8s}
        @keyframes fadeIn{from{opacity:0}to{opacity:1}}
        #conversation-flow{padding-bottom:25vh}
        .topic-paragraph{opacity:.5;transition:opacity .3s;cursor:pointer}.topic-paragraph:hover{opacity:1}
        .bicycle-image{opacity:0;animation:fadeIn 3s forwards}
    </style>
</head>
<body>
    <div class="view column align-center">
        <img src="./images/bicycle.png" alt="Bicycle" class="bicycle-image">
        <div class="box-s padding-xl column">
            <div id="introduction"><p id="typewriter-content"></p></div>
            <div id="conversation-flow"></div>
        </div>
    </div>

    <script>
        // Force scroll to top immediately and when DOM loads
        window.scrollTo(0, 0);
        document.addEventListener('DOMContentLoaded', () => {
            window.scrollTo(0, 0);
            setTimeout(() => window.scrollTo(0, 0), 50);
            new TypewriterController();
        });

        class Typewriter {
            constructor(element, options = {}) {
                this.element = element;
                this.words = element.textContent.trim();
                this.element.textContent = '';
                this.speed = options.speed || 1000;
                this.delay = options.delay || 10;
                this.onComplete = options.onComplete || (() => {});
                this.isRunning = false;
                this.controller = options.controller || null;
                this.currentParagraph = null;
            }

            async type() {
                if (this.isRunning) return;
                this.isRunning = true;
                
                this.element.innerHTML = '';
                this.currentParagraph = document.createElement('p');
                this.currentParagraph.className = 'paragraph';
                this.element.appendChild(this.currentParagraph);
                
                const chars = this.words.split('');
                let currentLine = '';
                
                for (const char of chars) {
                    if (!this.isRunning) break;
                    
                    if (char === '\n') {
                        if (currentLine.trim() !== '') {
                            this.currentParagraph.textContent = currentLine;
                            currentLine = '';
                        }
                        
                        this.currentParagraph = document.createElement('p');
                        this.currentParagraph.className = 'paragraph';
                        this.element.appendChild(this.currentParagraph);
                        
                        this.scrollToBottom();
                        await new Promise(resolve => setTimeout(resolve, this.delay / 3));
                    } else {
                        currentLine += char;
                        this.currentParagraph.textContent = currentLine;
                        
                        const delay = ['.', '!', '?'].includes(char) ? this.delay : 
                                     [',', ';'].includes(char) ? this.delay / 2 : this.speed;
                        
                        this.scrollToBottom();
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
                
                this.isRunning = false;
                this.onComplete();
            }

            scrollToBottom() {
                if (this.isUserAtBottom() || (this.controller && !this.controller.userHasScrolled)) {
                    window.scrollTo({top: document.body.scrollHeight, behavior: 'auto'});
                    if (this.controller) this.controller.userHasScrolled = false;
                }
            }
            
            isUserAtBottom() {
                if (this.controller) return this.controller.isUserAtBottom();
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const windowHeight = window.innerHeight;
                const documentHeight = Math.max(
                    document.body.scrollHeight, document.body.offsetHeight,
                    document.documentElement.clientHeight, document.documentElement.scrollHeight,
                    document.documentElement.offsetHeight
                );
                return documentHeight - (scrollTop + windowHeight) <= 100;
            }

            stop() { this.isRunning = false; }
        }

        class TypewriterController {
            constructor() {
                this.activeTypewriter = null;
                this.navButtons = Object.assign(document.createElement('div'), {
                    id: 'nav-buttons',
                    className: 'nav-buttons'
                });
                this.conversationFlow = document.getElementById('conversation-flow');
                this.answeredQuestions = new Set();
                this.isTyping = false;
                this.userHasScrolled = false;
                this.markdownSections = {};
                this.introText = "";
                this.typewriterSpeed = 15;
                this.typewriterDelay = 150;
                
                this.loadMarkdownContent();
                window.addEventListener('scroll', () => {
                    this.userHasScrolled = true;
                    setTimeout(() => { this.userHasScrolled = false; }, 2000);
                });

                // Add hash change listener
                window.addEventListener('hashchange', () => this.handleHashChange());
            }
            
            async loadMarkdownContent() {
                try {
                    const markdownText = await (await fetch('BICYCLE_FOR_THE_MIND.MD')).text();
                    const introEndIndex = markdownText.indexOf('## ');
                    this.introText = this.processMarkdown(
                        introEndIndex > 0 ? markdownText.substring(0, introEndIndex).trim() : markdownText.trim(), 
                        true
                    );
                    
                    const lines = markdownText.split('\n');
                    let currentSection = null;
                    let currentContent = [];
                    
                    for (const line of lines) {
                        if (line.startsWith('## ')) {
                            if (currentSection) {
                                this.markdownSections[currentSection] = this.processMarkdown(currentContent.join('\n'), true);
                                currentContent = [];
                            }
                            currentSection = line.substring(3).trim();
                        } else if (currentSection && !line.startsWith('# ')) {
                            currentContent.push(line);
                        }
                    }
                    
                    if (currentSection) {
                        this.markdownSections[currentSection] = this.processMarkdown(currentContent.join('\n'), true);
                    }
                    
                    this.createSectionButtons();
                    
                    // Check for initial hash before starting introduction
                    const initialHash = window.location.hash.substring(1);
                    if (initialHash) {
                        const sectionTitle = this.getSectionTitleFromHash(initialHash);
                        if (sectionTitle && this.markdownSections[sectionTitle]) {
                            // Skip introduction and show the requested section
                            this.showSection(this.getSectionId(sectionTitle), sectionTitle);
                            return;
                        }
                    }
                    
                    // If no valid hash or no hash at all, start with introduction
                    this.startIntroduction();
                } catch (error) {
                    console.error('Error loading markdown:', error);
                }
            }
            
            createSectionButtons() {
                this.navButtons.innerHTML = '';
                
                for (const sectionTitle in this.markdownSections) {
                    const paragraph = Object.assign(document.createElement('p'), {
                        className: 'topic-paragraph',
                        textContent: sectionTitle
                    });
                    paragraph.setAttribute('data-section', this.getSectionId(sectionTitle));
                    
                    paragraph.addEventListener('click', (e) => {
                        if (this.isTyping) return;
                        this.hideNavigation();
                        this.showSection(e.target.getAttribute('data-section'), sectionTitle);
                    });
                    
                    this.navButtons.appendChild(paragraph);
                }
            }
            
            getSectionId(title) {
                return title.toUpperCase()
                    .replace(/[^A-Z0-9]+/g, '-')
                    .replace(/^-+|-+$/g, '');
            }
            
            hideNavigation() {
                this.navButtons.classList.remove('visible');
            }
            
            async startIntroduction() {
                // Force scroll to top again before animations
                window.scrollTo(0, 0);
                
                // Wait for image to fade in
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                // Scroll smoothly to the typewriter content
                const introElement = document.getElementById('introduction');
                introElement.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start' 
                });
                
                // Small delay before starting to type
                await new Promise(resolve => setTimeout(resolve, 500));
                
                const typewriter = new Typewriter(document.getElementById('typewriter-content'), {
                    speed: this.typewriterSpeed,
                    delay: this.typewriterDelay,
                    onComplete: () => {
                        this.navButtons.classList.add('visible');
                        this.conversationFlow.appendChild(this.navButtons);
                    },
                    controller: this
                });
                
                typewriter.words = this.introText;
                this.activeTypewriter = typewriter;
                await typewriter.type();
            }
            
            async showSection(sectionId, sectionTitle) {
                if (this.answeredQuestions.has(sectionId)) return;
                
                this.answeredQuestions.add(sectionId);
                this.isTyping = true;
                
                // Update URL hash without triggering hashchange event
                const currentHash = window.location.hash;
                const newHash = `#${sectionId}`;
                if (currentHash !== newHash) {
                    window.location.hash = newHash;
                }
                
                const sectionElement = Object.assign(document.createElement('section'), {
                    id: `${sectionId}-section`,
                    className: 'section active'
                });
                
                sectionElement.appendChild(Object.assign(document.createElement('p'), {
                    className: 'question',
                    textContent: sectionTitle
                }));
                
                const contentDiv = Object.assign(document.createElement('div'), {
                    id: `${sectionId}-content`,
                    className: 'typewriter-content'
                });
                
                const answerDiv = document.createElement('div');
                answerDiv.appendChild(contentDiv);
                sectionElement.appendChild(answerDiv);
                this.conversationFlow.appendChild(sectionElement);
                
                const typewriter = new Typewriter(contentDiv, {
                    speed: this.typewriterSpeed,
                    delay: this.typewriterDelay,
                    onComplete: () => {
                        this.isTyping = false;
                        this.moveNavButtonsAfterLastSection();
                    },
                    controller: this
                });
                
                typewriter.words = this.markdownSections[sectionTitle];
                this.activeTypewriter = typewriter;
                await typewriter.type();
            }
            
            moveNavButtonsAfterLastSection() {
                if (this.navButtons.parentNode) {
                    this.navButtons.parentNode.removeChild(this.navButtons);
                }
                
                this.conversationFlow.appendChild(this.navButtons);
                this.updateNavButtons();
                
                if (this.isUserAtBottom()) {
                    window.scrollTo({top: document.body.scrollHeight, behavior: 'auto'});
                }
            }
            
            updateNavButtons() {
                let hasUnansweredQuestions = false;
                
                document.querySelectorAll('.topic-paragraph').forEach(paragraph => {
                    const sectionId = paragraph.getAttribute('data-section');
                    paragraph.style.display = this.answeredQuestions.has(sectionId) ? 'none' : 'block';
                    if (!this.answeredQuestions.has(sectionId)) hasUnansweredQuestions = true;
                });
                
                this.navButtons.classList.toggle('visible', hasUnansweredQuestions);
            }
            
            isUserAtBottom() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const windowHeight = window.innerHeight;
                const documentHeight = Math.max(
                    document.body.scrollHeight, document.body.offsetHeight,
                    document.documentElement.clientHeight, document.documentElement.scrollHeight,
                    document.documentElement.offsetHeight
                );
                return documentHeight - (scrollTop + windowHeight) <= 100;
            }
            
            removeMarkdownFormatting(text) {
                return text.replace(/\*\*(.*?)\*\*/g, '$1')
                    .replace(/\*(.*?)\*/g, '$1')
                    .replace(/^\s*-\s+/gm, '')
                    .replace(/^\s*#{1,6}\s*/gm, '')
                    .replace(/`{3}([\s\S]*?)`{3}/gm, '$1')
                    .replace(/`([^`]+)`/g, '$1')
                    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '$1')
                    .replace(/!\[([^\]]+)\]\(([^)]+)\)/g, '$1')
                    .replace(/^>\s*(.*?)$/gm, '$1')
                    .replace(/~~(.*?)~~/g, '$1')
                    .replace(/^---+$/gm, '')
                    .replace(/\n={2,}$/gm, '');
            }
            
            processMarkdown(text, plainText = false) {
                return plainText ? this.removeMarkdownFormatting(text) : marked.parse(text);
            }

            // Add new method to handle hash changes
            handleHashChange() {
                const hash = window.location.hash.substring(1);
                if (hash) {
                    const sectionTitle = this.getSectionTitleFromHash(hash);
                    if (sectionTitle && this.markdownSections[sectionTitle]) {
                        this.showSection(this.getSectionId(sectionTitle), sectionTitle);
                    }
                }
            }

            // Add new method to convert hash to section title
            getSectionTitleFromHash(hash) {
                return Object.keys(this.markdownSections).find(title => 
                    this.getSectionId(title) === hash
                );
            }
        }
    </script>
</body>
</html>

