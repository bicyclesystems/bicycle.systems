<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bicycle. Just think</title>
    <link rel="icon" href="./images/favicon.png" type="image/png">
    <script defer data-domain="bicycle.systems" src="https://plausible.io/js/script.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Times New Roman', Times, serif;
            line-height: 1.6; 
            color: #333; 
        }
        
        h1, h2, h3, h4, h5, h6 { font-weight: 500; line-height: 1.2; margin-bottom: 0.5em; }
        h5 { font-size: 1.8rem; margin-bottom: 1rem; }
        
        .view { min-height: 100vh; width: 100%; padding: 1rem; }
        .container { max-width: 800px; width: 100%; padding: 2rem; margin: 0 auto; }
        #conversation-flow { padding-bottom: 25vh; position: relative; }
        
        .bicycle-image { 
            width: 100vw; 
            margin-bottom: 2rem; 
            opacity: 1;
            transition: opacity 2s;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .bicycle-image.fade-out { opacity: 0; pointer-events: none; }
        
        .background-image-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            pointer-events: none;
            background-color: rgba(255, 255, 255, 0.97);
        }
        
        .background-image {
            position: absolute;
            display: none;
            mix-blend-mode: multiply;
            filter: contrast(1.05) brightness(1.1) saturate(0.9);
            max-height: 40vh;
            max-width: 40vw;
            object-fit: contain;
        }
        
        .background-image.active { display: block; }
        
        /* Position classes */
        .top-left { top: 40px; left: 40px; }
        .top-right { top: 40px; right: 40px; }
        .bottom-left { bottom: 40px; left: 40px; }
        .bottom-right { bottom: 40px; right: 40px; }
        .top-center { top: 40px; left: 50%; transform: translateX(-50%); }
        .bottom-center { bottom: 40px; left: 50%; transform: translateX(-50%); }
        .left-center { top: 50%; left: 40px; transform: translateY(-50%); }
        .right-center { top: 50%; right: 40px; transform: translateY(-50%); }
        
        .section {
            opacity: 0;
            height: 0;
            overflow: hidden;
            pointer-events: none;
            position: absolute;
            left: 0; right: 0;
        }
        
        .section.active {
            opacity: 1;
            height: auto;
            overflow: visible;
            pointer-events: auto;
            position: relative;
        }
        
        .nav-buttons {
            display: none;
            opacity: 0;
            margin-top: 2rem;
        }
        
        .nav-buttons.visible {
            display: flex;
            flex-direction: column;
            opacity: 1;
        }
        
        .topic-paragraph {
            opacity: 0.5;
            transition: opacity 0.3s;
            cursor: pointer;
            margin-bottom: 0.75rem;
        }
        
        .topic-paragraph:hover { opacity: 1; }
        .paragraph { margin-bottom: 1rem; }
        .question { font-weight: 500; margin-bottom: 1.5rem; }
        .typewriter-content { margin-bottom: 1rem; }
        
        @media (max-width: 768px) {
            .container { padding: 1rem; }
            .background-image { 
                max-height: 50vh;
                max-width: 60vw;
            }
        }
    </style>
</head>
<body>
    <div class="background-image-container" id="background-container"></div>
    <div class="view">
        <img src="./images/bicycle.png" alt="Bicycle" class="bicycle-image">
        <div class="container" style="mix-blend-mode:difference; color:white;">
            <div id="conversation-flow"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            window.scrollTo(0, 0);
            new BicycleApp();
        });

        class BicycleApp {
            constructor() {
                this.conversationFlow = document.getElementById('conversation-flow');
                this.bgContainer = document.getElementById('background-container');
                this.markdownSections = {};
                this.introText = "";
                this.activeTypewriter = null;
                this.isTyping = false;
                this.userHasScrolled = false;
                this.answeredQuestions = new Set();
                this.imageCache = {};
                this.positions = [
                    'top-left', 'top-right', 'bottom-left', 'bottom-right', 
                    'top-center', 'bottom-center', 'left-center', 'right-center'
                ];
                this.currentPosition = 0;
                this.currentTextPosition = null; // Track current text position
                
                // Create navigation buttons container
                this.navButtons = document.createElement('div');
                this.navButtons.id = 'nav-buttons';
                this.navButtons.className = 'nav-buttons';
                
                // Set up event listeners
                window.addEventListener('scroll', () => {
                    this.userHasScrolled = true;
                    setTimeout(() => this.userHasScrolled = false, 2000);
                });
                window.addEventListener('hashchange', () => this.handleHashChange());
                window.addEventListener('resize', () => this.resizeImages());
                
                // Initialize the app
                this.init();
            }
            
            async init() {
                try {
                    await this.loadContent();
                    const hash = window.location.hash.substring(1);
                    if (hash) {
                        const sectionTitle = this.getSectionTitleFromHash(hash);
                        if (sectionTitle && this.markdownSections[sectionTitle]) {
                            await this.showSection(this.getSectionId(sectionTitle), sectionTitle);
                            return;
                        }
                    }
                    this.startIntro();
                } catch (error) {
                    console.error('Error initializing app:', error);
                }
            }
            
            async loadContent() {
                try {
                    const response = await fetch('BICYCLE_FOR_THE_MIND.MD');
                    if (!response.ok) throw new Error(`Failed to fetch markdown: ${response.status}`);
                    
                    const text = await response.text();
                    const sections = this.parseMarkdown(text);
                    
                    if (sections.intro) this.introText = sections.intro;
                    this.markdownSections = sections.sections;
                    
                    this.createNavigationButtons();
                } catch (error) {
                    console.error('Error loading content:', error);
                }
            }
            
            parseMarkdown(text) {
                const lines = text.split('\n');
                let currentSection = null;
                let currentContent = [];
                let sections = {};
                let intro = "";
                
                for (const line of lines) {
                    if (line.startsWith('## ')) {
                        if (currentSection) {
                            sections[currentSection] = currentContent.join('\n');
                            currentContent = [];
                        } else if (currentContent.length > 0) {
                            intro = currentContent.join('\n');
                            currentContent = [];
                        }
                        currentSection = line.substring(3).trim();
                    } else if (currentSection) {
                        currentContent.push(line);
                    } else {
                        currentContent.push(line);
                    }
                }
                
                // Handle the last section
                if (currentSection) {
                    sections[currentSection] = currentContent.join('\n');
                } else if (currentContent.length > 0 && !intro) {
                    intro = currentContent.join('\n');
                }
                
                // If no intro but we have sections, use first section as intro
                if (!intro && Object.keys(sections).length > 0) {
                    const firstKey = Object.keys(sections)[0];
                    intro = sections[firstKey];
                    delete sections[firstKey];
                }
                
                return { intro, sections };
            }
            
            createNavigationButtons() {
                this.navButtons.innerHTML = '';
                
                for (const title in this.markdownSections) {
                    const btn = document.createElement('h5');
                    btn.className = 'topic-paragraph';
                    btn.textContent = title;
                    btn.dataset.section = this.getSectionId(title);
                    
                    btn.addEventListener('click', () => {
                        if (this.isTyping) return;
                        this.navButtons.classList.remove('visible');
                        this.showSection(btn.dataset.section, title);
                    });
                    
                    this.navButtons.appendChild(btn);
                }
            }
            
            getSectionId(title) {
                return title.toUpperCase().replace(/[^A-Z0-9]+/g, '-').replace(/^-+|-+$/g, '');
            }
            
            getSectionTitleFromHash(hash) {
                return Object.keys(this.markdownSections).find(
                    title => this.getSectionId(title) === hash
                );
            }
            
            async startIntro() {
                window.scrollTo(0, 0);
                
                const bicycleImage = document.querySelector('.bicycle-image');
                bicycleImage.classList.add('fade-out');
                
                await this.wait(2000);
                bicycleImage.style.display = 'none';
                
                // Create intro section
                const section = document.createElement('section');
                section.id = 'INTRODUCTION-section';
                section.className = 'section active';
                this.conversationFlow.appendChild(section);
                
                // Add content container
                const content = document.createElement('div');
                content.id = 'typewriter-content';
                content.className = 'typewriter-content';
                section.appendChild(content);
                
                this.isTyping = true;
                await this.typeText(content, this.introText, true);
                this.isTyping = false;
                
                // Move nav buttons after section
                if (this.navButtons.parentNode) {
                    this.navButtons.parentNode.removeChild(this.navButtons);
                }
                section.after(this.navButtons);
                this.navButtons.classList.add('visible');
                
                // Hide all background images
                document.querySelectorAll('.background-image.active')
                    .forEach(img => img.classList.remove('active'));
                
                // Update background
                this.bgContainer.style.backgroundColor = 'rgba(255, 255, 255, 1)';
            }
            
            async showSection(sectionId, sectionTitle) {
                // Check if section already exists
                const existingSection = document.getElementById(`${sectionId}-section`);
                if (existingSection) {
                    document.querySelectorAll('.section.active')
                        .forEach(s => s.classList.remove('active'));
                    existingSection.classList.add('active');
                    this.moveNavButtons(existingSection);
                    return;
                }
                
                if (this.answeredQuestions.has(sectionId)) return;
                this.answeredQuestions.add(sectionId);
                this.isTyping = true;
                
                // Update URL hash without triggering hashchange event
                const newHash = `#${sectionId}`;
                if (window.location.hash !== newHash) {
                    window.history.replaceState(null, '', newHash);
                }
                
                // Hide all active sections
                document.querySelectorAll('.section.active')
                    .forEach(s => s.classList.remove('active'));
                
                // Create new section
                const section = document.createElement('section');
                section.id = `${sectionId}-section`;
                section.className = 'section active';
                this.conversationFlow.appendChild(section);
                
                // Add question title
                const question = document.createElement('h5');
                question.className = 'question';
                question.textContent = sectionTitle;
                section.appendChild(question);
                
                // Add content container
                const contentWrapper = document.createElement('div');
                section.appendChild(contentWrapper);
                
                const content = document.createElement('div');
                content.id = `${sectionId}-content`;
                content.className = 'typewriter-content';
                contentWrapper.appendChild(content);
                
                // Type the content
                await this.typeText(content, this.markdownSections[sectionTitle], false);
                this.isTyping = false;
                
                // Move nav buttons
                this.moveNavButtons(section);
            }
            
            async typeText(element, text, enableImageMatch = false) {
                element.innerHTML = '';
                let currentParagraph = document.createElement('h5');
                currentParagraph.className = 'paragraph';
                element.appendChild(currentParagraph);
                
                const chars = text.split('');
                let currentLine = '';
                let currentWord = '';
                let shouldPause = false;
                
                for (const char of chars) {
                    // Update current text position
                    this.updateCurrentTextPosition(currentParagraph);
                    
                    if (char === '\n') {
                        if (currentLine.trim() !== '') {
                            currentParagraph.textContent = currentLine;
                            currentLine = '';
                        }
                        
                        if (enableImageMatch && currentWord.trim()) {
                            this.tryLoadImage(currentWord.trim());
                            currentWord = '';
                        }
                        
                        currentParagraph = document.createElement('h5');
                        currentParagraph.className = 'paragraph';
                        element.appendChild(currentParagraph);
                        this.scrollToBottom();
                        
                        // Add longer pause after line break
                        await this.wait(300);
                        shouldPause = false;
                    } else {
                        currentLine += char;
                        
                        if (enableImageMatch) {
                            if (/\s/.test(char) || /[.,!?;:]/.test(char)) {
                                if (currentWord.trim()) {
                                    this.tryLoadImage(currentWord.trim());
                                    currentWord = '';
                                }
                            } else {
                                currentWord += char;
                            }
                        }
                        
                        currentParagraph.textContent = currentLine;
                        
                        // Calculate delay based on character
                        let delay = 30; // Normal typing speed
                        
                        // Add pauses after punctuation
                        if (['.', '!', '?'].includes(char)) {
                            delay = 300; // Longer pause after sentence-ending punctuation
                            shouldPause = true;
                        } else if ([',', ';', ':'].includes(char)) {
                            delay = 150; // Medium pause after mid-sentence punctuation
                        } else if (shouldPause) {
                            // Extra delay after the first character following sentence punctuation
                            delay = 100;
                            shouldPause = false;
                        }
                        
                        this.scrollToBottom();
                        await this.wait(delay);
                    }
                }
                
                if (enableImageMatch && currentWord.trim()) {
                    this.tryLoadImage(currentWord.trim());
                }
            }
            
            // Track the current text position for placing images far from text
            updateCurrentTextPosition(element) {
                if (!element) return;
                
                const rect = element.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                const viewportWidth = window.innerWidth;
                
                // Determine which quadrant the text is in
                this.currentTextPosition = {
                    isTop: rect.top < (viewportHeight / 2),
                    isLeft: rect.left < (viewportWidth / 2),
                    element: element
                };
            }
            
            tryLoadImage(word) {
                if (word.length <= 2) return;
                
                word = word.toLowerCase().replace(/[^\w\s]/g, '');
                
                // Check cache first
                if (this.imageCache[word]) {
                    this.showImage(this.imageCache[word]);
                    return;
                }
                
                // Try to load new image
                const img = new Image();
                img.className = `background-image ${this.getPositionFarFromText()}`;
                
                img.onload = () => {
                    this.bgContainer.appendChild(img);
                    const imageInfo = { word, element: img };
                    this.imageCache[word] = imageInfo;
                    this.showImage(imageInfo);
                };
                
                img.onerror = () => {
                    // Image failed to load - do nothing
                };
                
                img.src = `intro/${word}.png`;
            }
            
            showImage(imageInfo) {
                // Hide current active images
                document.querySelectorAll('.background-image.active')
                    .forEach(img => img.classList.remove('active'));
                
                // Update position for variety and to be far from text
                const oldPosition = imageInfo.element.className.split(' ')[1];
                const newPosition = this.getPositionFarFromText();
                
                imageInfo.element.classList.remove(oldPosition);
                imageInfo.element.classList.add(newPosition);
                
                // Show image
                imageInfo.element.classList.add('active');
                this.resizeImages();
            }
            
            getPositionFarFromText() {
                // If we don't know where the text is, use original rotation method
                if (!this.currentTextPosition) {
                    return this.getNextPosition();
                }
                
                // Choose a position that's far from the current text position
                let oppositePositions = [];
                
                if (this.currentTextPosition.isTop && this.currentTextPosition.isLeft) {
                    // Text is in top-left, place image in bottom-right area
                    oppositePositions = ['bottom-right', 'bottom-center', 'right-center'];
                } else if (this.currentTextPosition.isTop && !this.currentTextPosition.isLeft) {
                    // Text is in top-right, place image in bottom-left area
                    oppositePositions = ['bottom-left', 'bottom-center', 'left-center'];
                } else if (!this.currentTextPosition.isTop && this.currentTextPosition.isLeft) {
                    // Text is in bottom-left, place image in top-right area
                    oppositePositions = ['top-right', 'top-center', 'right-center'];
                } else {
                    // Text is in bottom-right, place image in top-left area
                    oppositePositions = ['top-left', 'top-center', 'left-center'];
                }
                
                // Pick a random position from the opposite quadrant
                return oppositePositions[Math.floor(Math.random() * oppositePositions.length)];
            }
            
            getNextPosition() {
                const position = this.positions[this.currentPosition];
                this.currentPosition = (this.currentPosition + 1) % this.positions.length;
                return position;
            }
            
            moveNavButtons(section) {
                if (this.navButtons.parentNode) {
                    this.navButtons.parentNode.removeChild(this.navButtons);
                }
                
                section.after(this.navButtons);
                this.navButtons.classList.add('visible');
                
                if (this.isUserAtBottom()) {
                    window.scrollTo({top: document.body.scrollHeight, behavior: 'smooth'});
                }
            }
            
            handleHashChange() {
                const hash = window.location.hash.substring(1);
                if (!hash) return;
                
                const sectionTitle = this.getSectionTitleFromHash(hash);
                if (!sectionTitle || !this.markdownSections[sectionTitle]) return;
                
                const sectionId = this.getSectionId(sectionTitle);
                const existingSection = document.getElementById(`${sectionId}-section`);
                
                document.querySelectorAll('.section.active')
                    .forEach(s => s.classList.remove('active'));
                
                if (existingSection) {
                    existingSection.classList.add('active');
                    this.moveNavButtons(existingSection);
                } else {
                    this.showSection(sectionId, sectionTitle);
                }
            }
            
            resizeImages() {
                // Let CSS handle image sizing
            }
            
            scrollToBottom() {
                if (this.isUserAtBottom() || !this.userHasScrolled) {
                    window.scrollTo({top: document.body.scrollHeight, behavior: 'auto'});
                }
            }
            
            isUserAtBottom() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const windowHeight = window.innerHeight;
                const documentHeight = Math.max(
                    document.body.scrollHeight, document.body.offsetHeight,
                    document.documentElement.clientHeight, document.documentElement.scrollHeight,
                    document.documentElement.offsetHeight
                );
                return documentHeight - (scrollTop + windowHeight) <= 100;
            }
            
            wait(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }
    </script>
</body>
</html>