<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The birth of a new era (and The End of Traditional Computing as we know it).</title>
    <link rel="stylesheet" href="https://unpkg.com/@rnbws/renecss/dist/rene.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/2.0.3/marked.min.js"></script>
    <style>
        .section{display:none}.section.active{display:block;animation:fadeIn .5s}
        .nav-buttons{display:none}.nav-buttons.visible{display:flex;flex-direction:column;animation:fadeIn .8s}
        @keyframes fadeIn{from{opacity:0}to{opacity:1}}
        #conversation-flow{padding-bottom:25vh}
        .topic-paragraph{opacity:.5;transition:opacity .3s;cursor:pointer}.topic-paragraph:hover{opacity:1}
    </style>
</head>
<body>
    <div class="view align-center">
        <div class="box-s padding-xl column">
            <div id="introduction"><p id="typewriter-content"></p></div>
            <div id="conversation-flow"></div>
        </div>
    </div>

    <script>
        class Typewriter {
            constructor(element, options = {}) {
                this.element = element;
                this.words = element.textContent.trim();
                this.element.textContent = '';
                this.speed = options.speed || 1000;
                this.delay = options.delay || 10;
                this.onComplete = options.onComplete || (() => {});
                this.isRunning = false;
                this.controller = options.controller || null;
                this.currentParagraph = null;
            }

            async type() {
                if (this.isRunning) return;
                this.isRunning = true;
                
                this.element.innerHTML = '';
                this.currentParagraph = document.createElement('p');
                this.currentParagraph.className = 'paragraph';
                this.element.appendChild(this.currentParagraph);
                
                const chars = this.words.split('');
                let currentLine = '';
                
                for (const char of chars) {
                    if (!this.isRunning) break;
                    
                    if (char === '\n') {
                        if (currentLine.trim() !== '') {
                            this.currentParagraph.textContent = currentLine;
                            currentLine = '';
                        }
                        
                        this.currentParagraph = document.createElement('p');
                        this.currentParagraph.className = 'paragraph';
                        this.element.appendChild(this.currentParagraph);
                        
                        this.scrollToBottom();
                        await new Promise(resolve => setTimeout(resolve, this.delay / 3));
                    } else {
                        currentLine += char;
                        this.currentParagraph.textContent = currentLine;
                        
                        const delay = ['.', '!', '?'].includes(char) ? this.delay : 
                                     [',', ';'].includes(char) ? this.delay / 2 : this.speed;
                        
                        this.scrollToBottom();
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
                
                this.isRunning = false;
                this.onComplete();
            }

            scrollToBottom() {
                if (this.isUserAtBottom() || (this.controller && !this.controller.userHasScrolled)) {
                    window.scrollTo({top: document.body.scrollHeight, behavior: 'auto'});
                    if (this.controller) this.controller.userHasScrolled = false;
                }
            }
            
            isUserAtBottom() {
                if (this.controller) return this.controller.isUserAtBottom();
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const windowHeight = window.innerHeight;
                const documentHeight = Math.max(
                    document.body.scrollHeight, document.body.offsetHeight,
                    document.documentElement.clientHeight, document.documentElement.scrollHeight,
                    document.documentElement.offsetHeight
                );
                return documentHeight - (scrollTop + windowHeight) <= 100;
            }

            stop() { this.isRunning = false; }
        }

        class TypewriterController {
            constructor() {
                this.activeTypewriter = null;
                this.navButtons = Object.assign(document.createElement('div'), {
                    id: 'nav-buttons',
                    className: 'nav-buttons'
                });
                this.conversationFlow = document.getElementById('conversation-flow');
                this.answeredQuestions = new Set();
                this.isTyping = false;
                this.userHasScrolled = false;
                this.markdownSections = {};
                this.introText = "";
                
                this.loadMarkdownContent();
                window.addEventListener('scroll', () => {
                    this.userHasScrolled = true;
                    setTimeout(() => { this.userHasScrolled = false; }, 2000);
                });
            }
            
            async loadMarkdownContent() {
                try {
                    const markdownText = await (await fetch('INDEX.MD')).text();
                    const introEndIndex = markdownText.indexOf('## ');
                    this.introText = this.processMarkdown(
                        introEndIndex > 0 ? markdownText.substring(0, introEndIndex).trim() : markdownText.trim(), 
                        true
                    );
                    
                    const lines = markdownText.split('\n');
                    let currentSection = null;
                    let currentContent = [];
                    
                    for (const line of lines) {
                        if (line.startsWith('## ')) {
                            if (currentSection) {
                                this.markdownSections[currentSection] = this.processMarkdown(currentContent.join('\n'), true);
                                currentContent = [];
                            }
                            currentSection = line.substring(3).trim();
                        } else if (currentSection && !line.startsWith('# ')) {
                            currentContent.push(line);
                        }
                    }
                    
                    if (currentSection) {
                        this.markdownSections[currentSection] = this.processMarkdown(currentContent.join('\n'), true);
                    }
                    
                    this.createSectionButtons();
                    this.startIntroduction();
                } catch (error) {
                    console.error('Error loading markdown:', error);
                }
            }
            
            createSectionButtons() {
                this.navButtons.innerHTML = '';
                
                for (const sectionTitle in this.markdownSections) {
                    const paragraph = Object.assign(document.createElement('p'), {
                        className: 'topic-paragraph',
                        textContent: sectionTitle
                    });
                    paragraph.setAttribute('data-section', this.getSectionId(sectionTitle));
                    
                    paragraph.addEventListener('click', (e) => {
                        if (this.isTyping) return;
                        this.hideNavigation();
                        this.showSection(e.target.getAttribute('data-section'), sectionTitle);
                    });
                    
                    this.navButtons.appendChild(paragraph);
                }
            }
            
            getSectionId(title) {
                return title.toLowerCase().replace(/[^a-z0-9]+/g, '-');
            }
            
            hideNavigation() {
                this.navButtons.classList.remove('visible');
            }
            
            async startIntroduction() {
                const typewriter = new Typewriter(document.getElementById('typewriter-content'), {
                    speed: 25,
                    delay: 500,
                    onComplete: () => {
                        this.navButtons.classList.add('visible');
                        this.conversationFlow.appendChild(this.navButtons);
                    },
                    controller: this
                });
                
                typewriter.words = this.introText;
                this.activeTypewriter = typewriter;
                await typewriter.type();
            }
            
            async showSection(sectionId, sectionTitle) {
                if (this.answeredQuestions.has(sectionId)) return;
                
                this.answeredQuestions.add(sectionId);
                this.isTyping = true;
                
                const sectionElement = Object.assign(document.createElement('section'), {
                    id: `${sectionId}-section`,
                    className: 'section active'
                });
                
                sectionElement.appendChild(Object.assign(document.createElement('p'), {
                    className: 'question',
                    textContent: sectionTitle
                }));
                
                const contentDiv = Object.assign(document.createElement('div'), {
                    id: `${sectionId}-content`,
                    className: 'typewriter-content'
                });
                
                const answerDiv = document.createElement('div');
                answerDiv.appendChild(contentDiv);
                sectionElement.appendChild(answerDiv);
                this.conversationFlow.appendChild(sectionElement);
                
                const typewriter = new Typewriter(contentDiv, {
                    speed: 25,
                    delay: 500,
                    onComplete: () => {
                        this.isTyping = false;
                        this.moveNavButtonsAfterLastSection();
                    },
                    controller: this
                });
                
                typewriter.words = this.markdownSections[sectionTitle];
                this.activeTypewriter = typewriter;
                await typewriter.type();
            }
            
            moveNavButtonsAfterLastSection() {
                if (this.navButtons.parentNode) {
                    this.navButtons.parentNode.removeChild(this.navButtons);
                }
                
                this.conversationFlow.appendChild(this.navButtons);
                this.updateNavButtons();
                
                if (this.isUserAtBottom()) {
                    window.scrollTo({top: document.body.scrollHeight, behavior: 'auto'});
                }
            }
            
            updateNavButtons() {
                let hasUnansweredQuestions = false;
                
                document.querySelectorAll('.topic-paragraph').forEach(paragraph => {
                    const sectionId = paragraph.getAttribute('data-section');
                    paragraph.style.display = this.answeredQuestions.has(sectionId) ? 'none' : 'block';
                    if (!this.answeredQuestions.has(sectionId)) hasUnansweredQuestions = true;
                });
                
                this.navButtons.classList.toggle('visible', hasUnansweredQuestions);
            }
            
            isUserAtBottom() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const windowHeight = window.innerHeight;
                const documentHeight = Math.max(
                    document.body.scrollHeight, document.body.offsetHeight,
                    document.documentElement.clientHeight, document.documentElement.scrollHeight,
                    document.documentElement.offsetHeight
                );
                return documentHeight - (scrollTop + windowHeight) <= 100;
            }
            
            removeMarkdownFormatting(text) {
                return text.replace(/\*\*(.*?)\*\*/g, '$1')
                    .replace(/\*(.*?)\*/g, '$1')
                    .replace(/^\s*-\s+/gm, '')
                    .replace(/^\s*#{1,6}\s*/gm, '')
                    .replace(/`{3}([\s\S]*?)`{3}/gm, '$1')
                    .replace(/`([^`]+)`/g, '$1')
                    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '$1')
                    .replace(/!\[([^\]]+)\]\(([^)]+)\)/g, '$1')
                    .replace(/^>\s*(.*?)$/gm, '$1')
                    .replace(/~~(.*?)~~/g, '$1')
                    .replace(/^---+$/gm, '')
                    .replace(/\n={2,}$/gm, '');
            }
            
            processMarkdown(text, plainText = false) {
                return plainText ? this.removeMarkdownFormatting(text) : marked.parse(text);
            }
        }

        document.addEventListener('DOMContentLoaded', () => new TypewriterController());
    </script>
</body>
</html>

